### 别名、列表和数组> 别名可以对命令重命名。 列表是一组命令以逻辑与、逻辑或的关系串在一起，可以灵活地实现脚本程序的逻辑控制。#### 别名> 别名是避免输入长命令的手段，是为长命令起一个新的名字作为其缩写。```alias alias-name='original-command'alias dir=ls``````unalias [-a] [alias-name]unalias -a  # 删除所有的别名unalias alias-name  # 删除名称为alias-name的别名```> 混合型结构(if/then,循环和函数等)不能使用alias命令设置别名， 但是可以执行在混合型结构之外所设置的别名。#### 列表> 列表是由一串命令用与运算(&&)和或运算(||)连接而成， 用与运算连接的列表称为与列表(and list)，用或运算连接的列表称为或列表(or list)。* 与列表```# 从左到右依次执行，直到某命令返回FALSE时，与列表执行终止。command1 && command2 && ... && commandn```* 或列表```# 从左到右依次执行，直到某命令返回TRUE时，与列表执行终止。command1 || command2 || ... || commandn```* 嵌套列表：在使用与或列表嵌套时需要利用圆括号区分逻辑运算的优先级。#### 数组* 数组的基本用法> bash Shell 只支持一维数组，从0号开始标号，可以不连续地给数组赋值，允许数组空缺元素。```${array[x]}  # 引用array数组标号为x的值```* 不连续赋值    ```    city[0]=changyuan    city[1]=wuhan    city[5]=xian    echo "city[0]=${city[0]}"  # city[0]=changyuan    echo "city[1]=${city[1]}"  # city[1]=wuhan    echo "city[5]=${city[5]}"  # city[5]=xian    echo "city[2]=${city[2]}"  # city[2]=    echo "city[7]=${city[7]}"  # city[7]=    ```* 圆括号结构赋值    ```    city=(changyuan wuhan xian)    echo "city[0]=${city[0]}"  # city[0]=changyuan    echo "city[1]=${city[1]}"  # city[1]=wuhan    echo "city[2]=${city[2]}"  # city[0]=xian    echo "city[3]=${city[3]}"  # city[1]=    ```* 圆括号跳跃赋值    ```    city=(changyuan [4]=wuhan xian)    echo "city[0]=${city[0]}"  # city[0]=changyuan    echo "city[1]=${city[1]}"  # city[1]=    echo "city[2]=${city[2]}"  # city[2]=    echo "city[4]=${city[4]}"  # city[4]=wuhan    echo "city[5]=${city[5]}"  # city[5]=xian    echo "city[6]=${city[6]}"  # city[6]=    ```* 圆括号任意赋值    ```    city=([2]=changyuan [4]=wuhan [7]=xian)    echo "city[0]=${city[0]}"  # city[0]=    echo "city[1]=${city[1]}"  # city[1]=    echo "city[2]=${city[2]}"  # city[2]=changyuan    echo "city[3]=${city[3]}"  # city[3]=    echo "city[4]=${city[4]}"  # city[4]=wuhan    echo "city[5]=${city[5]}"  # city[5]=    echo "city[6]=${city[6]}"  # city[6]=    echo "city[7]=${city[7]}"  # city[7]=xian    echo "city[8]=${city[8]}"  # city[8]=    ```* 默认将变量看成只有一个元素的数组，@和*符号都可用来表示数组的元素。    ```    one_array=alisure    echo $one_array  # jiye    echo ${one_array[@]}  # jiye，@表示全部元素    echo ${one_array[*]}  # jiye，*表示全部元素    echo ${one_array[0]}  # jiye    echo ${one_array[1]}  # ,one_array[1]未被赋值    echo ${#one_array[1]}  # 0    echo ${#one_array[*]}  # 1    ```* 利用@和*打印所有的元素    ```    city=(changyuan wuhan xian)  # 如果是不连续的，未赋值的元素不会打印出来    for i in ${city[@]}  # 或者*    do        echo "$i"    done    ```> 当用引号将${city[@]}印起来时，将所有的元素分行打印。 当用引号将${city[]}印起来时，将所有的元素在一行内打印，中间以IFS分隔。 当不用引号时，@和完全等价.* 抽取子串    ```    city=(changyuan wuhan xian)    echo ${city[*]:0}  # 抽取整个子串：changyuan wuhan xian    echo ${city[*]:1}  # 抽取从第1个元素到结束的数组：wuhan xian    echo ${city[*]:2}  # 抽取从第2个元素到结束的数组：xian    echo ${city[*]:0:2}  # 抽取从第0个元素开始的2个元素：changyuan wuhan    ```* 删除子串/替换子串    ```    # 删除子串    city=(changyuan wuhan xian)    echo ${city[*]#a*n}  # 删除从c到a的最短子串(从开头匹配)：ngyuan wuhan xian    echo ${city[*]##a*n}  # 删除从c到a的最长子串(从开头匹配)：n wuhan xian        # 替换子串    echo ${city[*]/a*n}    ```* 清空元素(可理解为删除元素)    ```    declare -a array_name  # 将array_name声明为数组，不是必须的    read -a array_name  # 读入一行，以空格分隔每个元素        for i in "${array_name[@]}"    do         echo "$i"    done        unset array_name[1]  # 清空array_name[1]元素        unset array_name  # 清空整个数组    ```* 数组连接    ```    city1=(changyuan wuhan xian)    city2=(changyuan wuhan xian)    combine=(${city1[@]} ${city2[@]})  # combine是city1和city2的连接    echo ${combine[*]:0}  # changyuan wuhan xian changyuan wuhan xian    ```         