### 本部分内容* 捕捉一个文件、命令、程序或脚本* 管道* 面向文件的io重定向* shell如何对一个命令进行处理### 10.1 管道1. 管道简介    ```    command1 | command2 | command3 | ... | commandn    # command1的输出发送给command2,作为command2的输入，后面的命令依次类推。    # 如果没有管道，command1的输出结果直接显示在Shell上。    ```2. `cat`和`more`命令> cat和more命令用来显示文件的内容。```# 具体 option 查看帮助文档cat [option] filenamemore [option] [+linenum] filename  # [+linenum] 指定显示文件的起始行# cat命令不提供分页功能，more在显示超过一页的文件时提供了分页的功能。``````# 将ls的结果分页展示ls -l | more```3. sed命令与管道```sed [选项] 'sed命令' 输入文件  # 原始的sed命令| sed [选项] 'sed命令'  # sed命令与管道结合``````# 打印ls -l结果的第1~5行ls -l | sed -n '1,5p'``````# 结合命令替换、管道、sed、变量赋值、echo等知识variable1="abcdef"replace="123"variable2=`echo "$variable1" | sed "s/abc/$replace/g"`echo "$variable2"  # 123def```### 10.2 io重定向> io重定向是一个过程，这个过程捕捉一个文件、命令、程序和及哦啊本，甚至代码块的输出，然后把捕捉到的输出作为输入发送给另一个文件、命令、程序和脚本。1. 文件标识符> linux使用文件标识符（FD）来标示一个进程正在访问特定文件* tee命令> T型数据流，将一个输出分为两个支流，一个到标准输出，一个到某个输出文件。```# 将who的结果保存到output文件who | tee output# 将who的结果追加到output文件who | tee -a output```2. io重定向符号及其用法```cat > newfile  # 将键盘的输入重定向到newfile# 在此输入内容# 按CTRL+D结束输入cat >> newfile  # 将键盘的输入追加到newfile# 在此输入内容# 按CTRL+D结束输入cat newfile# 显示刚才编辑的内容``````n> filename  # 将文件标识符为n的内容输出到filename中# 将指定文件标识符的内容重定向到另一文件中ls z-file  # 假设：当前目录下没有z-filels z-file 2> newfile  # 将错误信息输入到newfile中``````< filename  #  将文件的内容读入（重定向）标准输入中n< filename  # 将文件的内容读入（重定向）文件标识符为n的文件中wc -l < filename  # 统计文件的行数```3. `exec`命令的用法> 可以通过文件标识符打开或关闭文件， 也可以将文件重定向到标准输入或将标准输出重定向到文件```exec 8<&0  # 将FD 0(标准输入)复制到FD 8exec < hfile  # 将hfile重定向到标准输入read a  # 读取hfile的第一行echo "$a"exec 0<&8 8<&-  # 将FD 8复制到FD 0(标准输入)，关闭FD 8的输入（恢复标准输入）exec 8>&1  # 将FD 1(标准输出)复制到FD 8exec > log  # 将标准输出重定向log文件echo "asd"  # 此时会将asd写入到log文件中exec 1>&8 8>&-  # 将FD 8复制到FD 1(标准输出)，关闭FD 8的输出（恢复标准输出）```4. 代码块重定向> 指在代码块内将标准输入或标准输出重定向到文件，而在代码块之外保留默认状态。 可以重定向的代码块是while,until,for等循环结构，也可以是if/then测试结构，甚至可以是函数。```# `标准输入`重定向到`文件`done > filename# `标准输出`重定向到`文件`done < filename``````ls /etc > log  # 将结果重定向到log中while [ "$filename" != "rc.d" ]; do    read filename    let "count+=1"done < log  # 将标准输入重定向到log文件echo "$count"```* if/then```if [condition]then    ...else    ...fi < filename``````if [ -z "$1" ]then    echo "is null"  # 输出到log文件中fi > log```### 10.3 命令行处理* [shell 命令行处理流程](http://blog.51cto.com/evillinux/1192072)* [shell解析命令行的过程以及eval命令](https://www.cnblogs.com/f-ck-need-u/p/7426371.html)> shell对每一个命令都要经过命令行处理流程进行处理。如，变量替换、通配符展开等。* eval 命令> eval命令将其参数作为命令行，让shell重新执行该命令* 由于命令行处理需要步骤，所以当在后面替换的时候出现了前面已经处理过的情况， 当执行命令时会发生错误，所以用eval表明处理后的命令还需要重新处理一遍再执行。* 如果命令中包含变量替换，且变量中包含任何需要shell在命令中直接看到的字符， 就需要使用eval命令，如命令结束符（;,|,&）、I/O重定向符（<,>）和引号等。```由于命令行处理需要步骤，所以当在后面替换的时候出现了前面已经处理过的情况， 当执行命令时会发生错误，所以用eval表明处理后的命令还需要重新处理一遍再执行。如果命令中包含变量替换，且变量中包含任何需要shell在命令中直接看到的字符， 就需要使用eval命令，如命令结束符（;,|,&）、I/O重定向符（<,>）和引号等。```