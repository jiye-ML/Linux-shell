1. gdb调试
2. makefile的编写
3. 系统IO函数


1. gdb调试:
		1. 启动gdb
				start -- 只执行一步
					n -- next
					s -- step(单步) -- 可以进入到函数体内部
					c - continue -- 直接停在断点的位置
				
		2. 查看代码:
				l -- list
				l 10（函数名）
				l filename：行号（函数名）
		3. 设置断点:
				设置当前文件断点:
					b -- break
					b 10（函数名）
					b fileName:行号（函数名）
				设置指定文件断点:
				
				设置条件断点:
					b 10 if value==19
				删除断点:
					delete -- del - d
					d 断点的编号
						获取编号： info -- i
											info b
		4. 查看设置的断点
		5. 开始 执行gdb调试
				执行一步操作: 
					继续执行:
				执行多步, 直接停在断点处:
		5. 单步调试
				进入函数体内部: s
					从函数体内部跳出: finish
				不进入函数体内部:
					n
				退出当前循环: u
		6. 查看变量的值: p -- print
		7. 查看变量的类型: ptype 变量名
		8. 设置变量的值:	set var 变量名 = 赋值
		9. 设置追踪变量
				display
				取消追踪变量
				undisplay 编号
						获取编号： info display
		10. 退出gdb调试
					quit
		
2. makefile的编写:
		1. makefile的命名
		2. makefile的规则:
				规则中的三要素: 目标， 依赖， 命令
					目标：依赖条件
						命令
				子目标和终极目标的关系:
				更新目标的原则:
		3. makefile的两个函数
				wildcard
				patsubst
		4. makefile的三个自动变量
				$<
				$@
				$^

3. 系统IO函数
		1>. 一些概念
			文件描述符
			PCB
			C库函的IO缓冲区
				
		2>. open
				打开方式:
					必选项:
						O_RDONLY
						O_WRONLY
						O_RDWR
					可选项:
						O_CREAT
							文件权限: 本地有一个掩码
									文件的实际权限:
									给定的权限
									本地掩码(取反)
								&
									实际的文件权限
									777
									111111111
									111111101
									111111101
									775
									
						O_TRUNC
						O_EXCL
						O_APPEND
		3>. read
				返回值:
					1. -1 读文件失败
					2. 0 文件读完了
					3. >0 读取的字节数
		4>. write
				返回值:
		5>. lseek
				返回值:
		6>. close
				返回值:
				
				
cpu 为什么要使用虚拟地址空间与物理地址空间映射？解决了什么样的问题？

1.方便编译器和操作系统安排程序的地址分布。
		程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
		
2.方便进程之间隔离
		不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存。
		
3.方便OS使用你那可怜的内存。
		程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，
		内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
		
		
		
		
		
		
		
		
		
		
		
		
		
app:main.o sub.o mul.o
	gcc main.o sub.o mul.o -o app
	gcc $^ -o $@
		
%.o:%.c 
	gcc -c $< -o $@

makefile中的自动变量
$<: 规则中的第一个依赖
$@: 规则中的目标
$^: 规则中的所有依赖
只能在规则的命令中使用
	
		
