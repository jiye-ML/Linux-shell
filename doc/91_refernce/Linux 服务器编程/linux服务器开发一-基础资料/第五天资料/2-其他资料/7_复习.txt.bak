1. gdb -- 命令
		1. 前提条件: 可执行文件必须包含调试信息 gcc -g
		2. gdb 文件名 -- 启动gdb调试
		3. 查看代码的命令:
				当前文件: 
					list 行号(函数名)
				指定文件:
					list 文件名:行号(函数名)
		4. 设置断点
				当前文件:
					b 行号(函数名)
				指定文件:
					b 文件名:行号(函数名)
				设置条件断点:
					b 行号 if value==23
				查看断点信息:
					info b
				删除断点
					d 断点的编号
		5. 开始调试
				只执行一行代码: start
					继续执行停在断点处: continue -- c
				直接停在断点处: run -- r
		6. 单步调试:
				进入到函数体: step -- s
					跳出函数体: finish (如果在循环处有断点, 需要将断点删掉)
				不进入函数体: next -- n
		7. 追踪变量:
				自动打印变量的值: display 变量名
				取消变量的追踪: undisplay 编号
						获取编号: info display
				手动打印变量的值: print -- p
				获取变量对应的类型: ptype 
		8. 跳出循环: u
		9. 退出gdb: quit
		
Makefile
1. 一个规则
		三要素: 目标, 依赖, 命令
		目标:依赖
			命令
		
		1. 第一条规则是用来生成终极目标的规则
				1>. 如果规则中的依赖不存在, 向下寻找其他的规则,
				2>. 更新机制: 比较的是目标文件和依赖文件的时间
				
2. 两个函数
		1. 查找指定目录下, 指定类型的文件
				src=$(wildcard ~/aa/*.c)
		2. 匹配替换函数
				obj=$(patsubst %.c, %.o, $(src))
3. 三个自动变量
		1. $<: 规则中的第一个依赖
		2. $^: 规则中的所有依赖
		3. $@: 规则中的目标
		只能在规则中的命令中使用
4. 模式规则
		%.o:%.c
			gcc -c $< -o $@
			
Linux 系统IO函数
1. 文件描述符
		int 类型
		一个进程最多可打开多少文件: 
2. pcb
		进程控制块
		在其中有一个文件描述符表 -- 数组[1024]
		
3. 虚拟地址空间
		用户区, 内核区
		
		代码段
		已经初始化的全局变量
		未被初始化的全局变量
		堆 -- 从下往上
		共享库
		栈 - 从上往下
		环境变量
		内核区

4. 读大文件 -- 写入另一个文件

两种方式: 
	read write  -- 每次读1个byte
	getc putc   -- 每次读一个byte -- 效率高
			标准c库函数, 内部有一个缓冲区
			
	
两种方式, 哪个效率高

lseek
1. 获取文件大小
2. 移动文件指针
